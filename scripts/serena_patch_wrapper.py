#!/usr/bin/env python3
"""
Bridges Spec Agent patch requests to Serena (or a fallback stub).

The wrapper reads a JSON payload from stdin with the following shape:
{
    "repo_path": "/path/to/repo",
    "plan_id": "...",
    "step_description": "..."
}

It must emit a JSON payload with `diff`, `rationale`, and `alternatives`
for the patch engine to consume. When the SERENA_PATCH_DELEGATE environment
variable is set, this script forwards the payload to that command; otherwise
it returns a deterministic placeholder diff so the integration can be tested
without a running Serena instance.
"""

from __future__ import annotations

import json
import os
import re
import shlex
import subprocess
import sys
from pathlib import Path
from textwrap import dedent


def _run_delegate(command: str, payload: dict) -> str:
    completed = subprocess.run(
        shlex.split(command),
        input=json.dumps(payload),
        text=True,
        capture_output=True,
        check=True,
    )
    return completed.stdout


def _slugify(value: str) -> str:
    slug = re.sub(r"[^a-z0-9]+", "-", value.lower()).strip("-")
    return slug or "step"


def _placeholder_response(repo_path: Path, plan_id: str, step_description: str) -> dict:
    slug = _slugify(step_description)[:40]
    note_path = Path(".spec_agent") / "serena" / f"{plan_id}-{slug}.md"
    diff = dedent(
        f"""\
        --- a/{note_path}
        +++ b/{note_path}
        @@
        +## {step_description.strip()}
        +
        +- Repository: {repo_path}
        +- Plan ID: {plan_id}
        +- Generated by serena_patch_wrapper placeholder.
        """
    )
    rationale = (
        "Placeholder diff produced by serena_patch_wrapper. "
        "To use real Serena integration:\n"
        "1. Install MCP: pip install mcp\n"
        "2. Set SERENA_PATCH_DELEGATE: export SERENA_PATCH_DELEGATE='python $(pwd)/scripts/serena_mcp_integration.py'\n"
        "3. Or configure in ~/.spec_agent/env"
    )
    alternatives = [
        "Set SERENA_PATCH_DELEGATE environment variable to point to serena_mcp_integration.py",
        "Install MCP library: pip install mcp",
        "Configure Serena MCP server command via SERENA_MCP_COMMAND",
    ]
    return {"diff": diff, "rationale": rationale, "alternatives": alternatives}


def main() -> int:
    payload = json.loads(sys.stdin.read() or "{}")
    repo_path = Path(payload.get("repo_path", "."))
    plan_id = payload.get("plan_id", "unknown-plan")
    step_description = payload.get("step_description", "unspecified step")

    # Check for explicit delegate first (required - no fallback)
    delegate_cmd = os.getenv("SERENA_PATCH_DELEGATE")
    if not delegate_cmd:
        # Try to use real Serena MCP integration if available
        script_dir = Path(__file__).parent
        mcp_integration = script_dir / "serena_mcp_integration.py"
        if mcp_integration.exists():
            delegate_cmd = f"{sys.executable} {mcp_integration}"
        else:
            error_response = {
                "diff": "",
                "rationale": (
                    "SERENA_PATCH_DELEGATE not set and serena_mcp_integration.py not found. "
                    "Set SERENA_PATCH_DELEGATE to point to your Serena integration script."
                ),
                "alternatives": [
                    "Set SERENA_PATCH_DELEGATE: export SERENA_PATCH_DELEGATE='python $(pwd)/scripts/serena_mcp_integration.py'",
                    "Or configure in ~/.spec_agent/env",
                ],
            }
            json.dump(error_response, sys.stdout)
            sys.stderr.write("Error: SERENA_PATCH_DELEGATE not configured\n")
            return 1
    
    # Call the delegate (no fallback - fail if it fails)
    try:
        stdout = _run_delegate(delegate_cmd, payload)
        # Validate the response
        try:
            response_data = json.loads(stdout)
            # Check if it's an error response (but allow connection success messages)
            rationale = response_data.get("rationale", "")
            has_diff = response_data.get("diff") and response_data.get("diff").strip()
            
            # Only treat as error if: no diff AND rationale indicates failure (not success)
            is_error = (
                not has_diff 
                and rationale.startswith(("Error", "Failed", "Serena integration failed", "Serena MCP integration failed"))
                and "connected successfully" not in rationale.lower()
            )
            
            if is_error:
                error_msg = rationale or "Unknown error from Serena delegate"
                sys.stderr.write(f"Serena delegate returned error: {error_msg}\n")
                json.dump(response_data, sys.stdout)
                return 1
            # Valid response (has diff or connection success message)
            sys.stdout.write(stdout)
            return 0
        except json.JSONDecodeError:
            # Not valid JSON - might be raw output, pass it through but warn
            sys.stderr.write("Warning: Serena delegate returned non-JSON output\n")
            sys.stdout.write(stdout)
            return 0
    except subprocess.CalledProcessError as exc:
        stderr_text = exc.stderr.decode() if exc.stderr and isinstance(exc.stderr, bytes) else (exc.stderr or "No stderr")
        error_response = {
            "diff": "",
            "rationale": f"Serena delegate command failed: {exc}",
            "alternatives": [
                f"Check stderr: {stderr_text}",
                "Verify SERENA_PATCH_DELEGATE points to a valid script",
                "Ensure the script has execute permissions",
            ],
        }
        json.dump(error_response, sys.stdout)
        sys.stderr.write(f"Serena delegate command failed: {exc}\n")
        if exc.stderr:
            sys.stderr.write(f"stderr: {stderr_text}\n")
        return 1
    except Exception as exc:
        error_response = {
            "diff": "",
            "rationale": f"Error running Serena delegate: {exc}",
            "alternatives": [
                "Verify SERENA_PATCH_DELEGATE is correctly configured",
                "Check that the delegate script exists and is executable",
            ],
        }
        json.dump(error_response, sys.stdout)
        sys.stderr.write(f"Error running Serena delegate: {exc}\n")
        return 1


if __name__ == "__main__":
    raise SystemExit(main())

